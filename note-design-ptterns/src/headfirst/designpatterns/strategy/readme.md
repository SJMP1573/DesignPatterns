
## （一）策略模式

#### 1.引言

当在开发过程中，遇到如下场景：

- 不同的鸭子具有不同的飞行行为，例如，一般的鸭子具有飞行的行为，橡皮鸭和模型鸭不具有飞行的行为...
- 购物时，不同会员等级对应的商品价格折扣是不同的，折扣具有不同的算法，例如，金牌会员打7折，银牌会员打8折，铜牌会员打9折；

就上述场景而言，针对某一问题，具有不同的应对策略（行为或算法等，统称策略）。

鸭子的飞行策略可能根据需求而变化，例如，添加一种火箭鸭，其飞行由火箭动力驱动。

如果不对这些变化的策略进行抽象和封装，可能引起代码无法复用、可维护性差和可扩展性差等问题。

在这种场景下，可以应用策略模式，来解决上述问题。

#### 2.利用继承和接口添加鸭子飞行行为

一款关于鸭子的游戏，鸭子Duck是抽象类，它有很多不同类型鸭子的实现。

现在需要为鸭子加入飞行的功能，即fly()，并且不同的鸭子具有不同的飞行行为。


一、利用继承的方法

设计方案如类图1所示：

Duck是抽象父类，其具有飞行行为fly()，但其子类RubberDuck不具有飞行行为，

因此，在子类RubberDuck()中，重写fly()，覆盖父类的fly()方法，使其成为一个空方法，

不具有飞行行为。

如果新增一只诱饵鸭DecoyDuck，重写父类的fly()方法，使其不具有飞行行为，

这使得fly()空方法在子类无法复用，每增加一个不具有飞行行为的鸭子子类均要重写fly()空方法。

试想，如果子类的fly()空方法，具有大量代码，这就会使得更多的代码无法复用。


二、利用接口的方法

设计方案如类图2所示：

把fly()从超类中取出来，放进一个“Flyable接口”中。这么一来，只有会飞的鸭子才实现此接口。

根据不同的鸭子，实现自己的飞行行为。

但这样也使得，每增加一类具有飞行行为的鸭子时，其飞行行为也无法复用。


#### 3.利用策略模式添加鸭子飞行行为

设计方案如类图3所示：

鸭子的飞行行为是变化的部分，因此将飞行行为封装起来，通过Duck与FlyBehavior的组合，
实现鸭子行为的与其他代码解耦，以后若有新的飞行行为，可通过实现FlyBehavior接口添加飞行行为即可，
这具有较好的扩展性和可维护性，也有利于维护代码。





